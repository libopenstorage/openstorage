syntax = "proto3";

import "google/protobuf/timestamp.proto";
import "google/api/annotations.proto";

package openstorage.api;

option go_package = "api";
option java_multiple_files = true;
option java_package = "com.openstorage.api";

enum Status {
  STATUS_NONE = 0;
  STATUS_INIT = 1;
  STATUS_OK = 2;
  STATUS_OFFLINE = 3;
  STATUS_ERROR = 4;
  STATUS_NOT_IN_QUORUM = 5;
  STATUS_DECOMMISSION = 6;
  STATUS_MAINTENANCE = 7;
  STATUS_STORAGE_DOWN = 8;
  STATUS_STORAGE_DEGRADED = 9;
  STATUS_NEEDS_REBOOT = 10;
  STATUS_STORAGE_REBALANCE = 11;
  STATUS_STORAGE_DRIVE_REPLACE = 12;
  STATUS_NOT_IN_QUORUM_NO_STORAGE = 13;
  // Add statuses before MAX and update the number for MAX
  STATUS_MAX = 14;
}

enum DriverType {
  DRIVER_TYPE_NONE = 0;
  DRIVER_TYPE_FILE = 1;
  DRIVER_TYPE_BLOCK = 2;
  DRIVER_TYPE_OBJECT = 3;
  DRIVER_TYPE_CLUSTERED = 4;
  DRIVER_TYPE_GRAPH = 5;
}

enum FSType {
  FS_TYPE_NONE = 0;
  FS_TYPE_BTRFS = 1;
  FS_TYPE_EXT4 = 2;
  FS_TYPE_FUSE = 3;
  FS_TYPE_NFS = 4;
  FS_TYPE_VFS = 5;
  FS_TYPE_XFS = 6;
  FS_TYPE_ZFS = 7;
}

enum GraphDriverChangeType {
  GRAPH_DRIVER_CHANGE_TYPE_NONE = 0;
  GRAPH_DRIVER_CHANGE_TYPE_MODIFIED = 1;
  GRAPH_DRIVER_CHANGE_TYPE_ADDED = 2;
  GRAPH_DRIVER_CHANGE_TYPE_DELETED = 3;
}

enum SeverityType {
  SEVERITY_TYPE_NONE = 0;
  SEVERITY_TYPE_ALARM = 1;
  SEVERITY_TYPE_WARNING = 2;
  SEVERITY_TYPE_NOTIFY = 3;
}

enum ResourceType {
  RESOURCE_TYPE_NONE = 0;
  RESOURCE_TYPE_VOLUME = 1;
  RESOURCE_TYPE_NODE = 2;
  RESOURCE_TYPE_CLUSTER = 3;
  RESOURCE_TYPE_DRIVE = 4;
}

enum AlertActionType {
  ALERT_ACTION_TYPE_NONE = 0;
  ALERT_ACTION_TYPE_DELETE = 1;
  ALERT_ACTION_TYPE_CREATE = 2;
  ALERT_ACTION_TYPE_UPDATE = 3;
}

enum VolumeActionParam {
  VOLUME_ACTION_PARAM_NONE = 0;
  // Maps to the boolean value false
  VOLUME_ACTION_PARAM_OFF = 1;
  // Maps to the boolean value true.
  VOLUME_ACTION_PARAM_ON = 2;
}

enum CosType {
  NONE = 0;
  LOW = 1;
  MEDIUM = 2;
  HIGH = 3;
}

enum IoProfile {
  IO_PROFILE_SEQUENTIAL = 0;
  IO_PROFILE_RANDOM= 1;
  IO_PROFILE_DB = 2;
  IO_PROFILE_DB_REMOTE = 3;
  IO_PROFILE_CMS = 4;
}

// VolumeState represents the state of a volume.
enum VolumeState {
  VOLUME_STATE_NONE = 0;
  // Volume is transitioning to new state
  VOLUME_STATE_PENDING = 1;
  // Volume is ready to be assigned to a container
  VOLUME_STATE_AVAILABLE = 2;
  // Volume is attached to container
  VOLUME_STATE_ATTACHED = 3;
  // Volume is detached but associated with a container
  VOLUME_STATE_DETACHED = 4;
  // Volume detach is in progress
  VOLUME_STATE_DETATCHING = 5;
  // Volume is in error state
  VOLUME_STATE_ERROR = 6;
  // Volume is deleted, it will remain in this state
  // while resources are asynchronously reclaimed
  VOLUME_STATE_DELETED = 7;
  // Volume is trying to be detached
  VOLUME_STATE_TRY_DETACHING = 8;
  // Volume is undergoing restore
  VOLUME_STATE_RESTORE = 9;
}

// VolumeStatus represents a health status for a volume.
enum VolumeStatus {
  VOLUME_STATUS_NONE = 0;
  // Volume is not present
  VOLUME_STATUS_NOT_PRESENT = 1;
  // Volume is healthy
  VOLUME_STATUS_UP = 2;
  // Volume is in fail mode
  VOLUME_STATUS_DOWN = 3;
  // Volume is up but with degraded performance
  // In a RAID group, this may indicate a problem with one or more drives
  VOLUME_STATUS_DEGRADED = 4;
}

enum StorageMedium {
  // Magnetic spinning disk.
  STORAGE_MEDIUM_MAGNETIC = 0;
  // SSD disk
  STORAGE_MEDIUM_SSD = 1;
  // NVME disk
  STORAGE_MEDIUM_NVME = 2;
}

enum ClusterNotify {
 // Node is down
 CLUSTER_NOTIFY_DOWN = 0;
}

enum AttachState {
    // Attached and available externally
    ATTACH_STATE_EXTERNAL = 0;
    // Attached but only available internally
    ATTACH_STATE_INTERNAL = 1;
    // Switching from External to Internal
    ATTACH_STATE_INTERNAL_SWITCH = 2;
}

enum OperationFlags {
  OP_FLAGS_UNKNOWN = 0;
  OP_FLAGS_NONE = 1;
  // Perform a force_detach during detach operation
  OP_FLAGS_DETACH_FORCE = 2;
}

// StorageResource groups properties of a storage device.
// swagger:model
message StorageResource {
  // Id is the LUN identifier.
  string id = 1;
  // Path device path for this storage resource.
  string path = 2;
  // Storage medium.
  StorageMedium medium = 3;
  // True if this device is online.
  bool online = 4;;
  // IOPS
  uint64 iops = 5;;
  // SeqWrite
  double seq_write = 6;
  // SeqRead
  double seq_read = 7;
  // RandRW
  double randRW  = 8;
  // Total size in bytes.
  uint64 size = 9;;
  // Physical Bytes used.
  uint64 used = 10;
  // True if this device is rotational.
  string rotation_speed = 11;
  // Timestamp of last time this device was scanned.
  google.protobuf.Timestamp last_scan = 12;
  // True if dedicated for metadata.
  bool metadata = 13;
}

// StoragePool groups different storage devices based on their CosType
message StoragePool {
  // ID pool ID
  int32 ID = 1;
  // Cos reflects the capabilities of this drive pool
  CosType Cos = 2;
  // Medium underlying storage type
  StorageMedium Medium = 3;
  // RaidLevel storage raid level
  string RaidLevel = 4;
  // TotalSize of the pool
  uint64 TotalSize = 7;
  // Used size of the pool
  uint64 Used = 8;
  // Labels is a list of user defined name-value pairs
  map<string, string> labels = 9;
}

// VolumeLocator is a structure that is attached to a volume
// and is used to carry opaque metadata.
// swagger:model
message VolumeLocator {
  // User friendly identifier
  string name = 1;
  // A set of name-value pairs that acts as search filters
  map<string, string> volume_labels = 2;
}

// Source is a structure that can be given to a volume
// to seed the volume with data.
// swagger:model
message Source {
  // A volume id, if specified will create a clone of the parent.
  string parent = 1;
  // Seed will seed the volume from the specified URI
  // Any additional config for the source comes from the labels in the spec
  string seed = 2;
}

// Group represents VolumeGroup / namespace
// All volumes in the same group share this object.
// swagger:model
message Group {
  // Id common identifier across volumes that have the same group.
  string id = 1;
}

// VolumeSpec has the properties needed to create a volume.
// swagger:model
message VolumeSpec {
  // Ephemeral storage
  bool ephemeral = 1;
  // Size specifies the thin provisioned volume size.
  uint64 size = 2;
  // Format specifies the filesystem for this volume.
  FSType format = 3;
  // BlockSize for the filesystem.
  int64 block_size = 4;
  // HaLevel specifies the number of copies of data.
  int64 ha_level = 5;
  // Cos specifies the relative class of service.
  CosType cos = 6;
  // IoProfile provides a hint about application using this volume.
  IoProfile io_profile = 7;
  // Dedupe specifies if the volume data is to be de-duplicated.
  bool dedupe = 8;
  // SnapshotInterval in minutes, set to 0 to disable snapshots
  uint32 snapshot_interval = 9;
  // VolumeLabels configuration labels
  map<string, string> volume_labels = 10;
  // Shared is true if this volume can be remotely accessed.
  bool shared = 11;
  // ReplicaSet is the desired set of nodes for the volume data.
  ReplicaSet replica_set = 12;
  // Aggregatiokn level Specifies the number of parts the volume can be aggregated from.
  uint32 aggregation_level = 13;
  // Encrypted is true if this volume will be cryptographically secured.
  bool encrypted = 14;
  // Passphrase for an encrypted volume
  string passphrase = 15;
  // SnapshotSchedule a well known string that specifies when snapshots should be taken.
  string snapshot_schedule = 16;
  // Scale allows autocreation of volumes.
  uint32 scale = 17;
  // Sticky volumes cannot be deleted until the flag is removed.
  bool sticky = 18;
  // Group identifies a consistency group
  Group group = 21;
  // GroupEnforced is true if consistency group creation is enforced.
  bool group_enforced = 22;
  // Compressed is true if this volume is to be compressed.
  bool compressed = 23;
  // Cascaded is true if this volume can be populated on any node from an external source.
  bool cascaded = 24;
  // Journal is true if data for the volume goes into the journal.
  bool journal = 25;
  // Sharedv4 is true if this volume can be accessed via sharedv4.
  bool sharedv4 = 26;
}

// ReplicaSet set of machine IDs (nodes) to which part of this volume is erasure
// coded - for clustered storage arrays
// swagger:model
message ReplicaSet {
  repeated string nodes = 1;
}

// RuntimeStateMap is a list of name value mapping of driver specific runtime
// information.
// swagger:model
message RuntimeStateMap {
  map<string, string> runtime_state = 1;
}

// Volume represents an abstract storage volume.
// Volume represents an abstract storage volume.
// swagger:model
message Volume {
  // Self referential volume ID.
  string id = 1;
  // Source specified seed data for the volume.
  Source source = 2;
  // Group volumes in the same group have the same group id.
  Group group = 3;
  // Readonly is true if this volume is to be mounted with readonly access.
  bool readonly = 4;
  // User specified locator
  VolumeLocator locator = 5;
  // Volume creation time
  google.protobuf.Timestamp ctime = 6;
  // User specified VolumeSpec
  VolumeSpec spec = 7;
  // Usage is bytes consumed by vtheis volume.
  uint64 usage = 8;
  // LastScan is the time when an integrity check was run.
  google.protobuf.Timestamp last_scan = 9;
  // Format specifies the filesytem for this volume.
  FSType format = 10;
  // Status is the availability status of this volume.
  VolumeStatus status = 11;
  // State is the current runtime state of this volume.
  VolumeState state = 12;
  // AttachedOn is the node instance identifier for clustered systems.
  string attached_on = 13;
  // AttachedState shows whether the device is attached for internal or external use.
  AttachState attached_state = 14;
  // DevicePath is the device exported by block device implementations.
  string device_path = 15;
  // SecureDevicePath is the device path for an encrypted volume.
  string secure_device_path = 16;
  // AttachPath is the mounted path in the host namespace.
  repeated string attach_path = 17;
  // AttachInfo is a list of name value mappings that provides attach information.
  map<string, string> attach_info = 18;
  // ReplicatSets storage for this volumefor clustered storage arrays.
  repeated ReplicaSet replica_sets = 19;
  // RuntimeState is a lst of name value mapping of driver specific runtime
  // information.
  repeated RuntimeStateMap runtime_state = 20;
  // Error is the Last recorded error.
  string error = 21;
  // VolumeConsumers are entities that consume this volume
  repeated VolumeConsumer volume_consumers = 22;
}

// Stats is a structure that represents last collected stats for a volume
// swagger:model
message Stats {
  // Reads completed successfully
  uint64 reads = 1;
  // Time spent in reads in ms
  uint64 read_ms = 2;
  uint64 read_bytes = 3;
  // Writes completed successfully
  uint64 writes = 4;
  // Time spent in writes in ms
  uint64 write_ms = 5;
  uint64 write_bytes = 6;
  // IOs curently in progress
  uint64 io_progress = 7;
  // Time spent doing IOs ms
  uint64 io_ms = 8;
  // BytesUsed
  uint64 bytes_used = 9;
  // Interval in ms during which stats were collected
  uint64 interval_ms = 10;
}


// Alert is a structure that represents an alert object
// swagger:model
message Alert {
  // Id for Alert
  int64 id = 1;
  // Severity of the Alert
  SeverityType severity = 2;
  // AlertType user defined alert type
  int64 alert_type = 3;
  // Message describing the Alert
  string message = 4;
  //Timestamp when Alert occured
  google.protobuf.Timestamp timestamp = 5;
  // ResourceId where Alert occured
  string resource_id = 6;
  // Resource where Alert occured
  ResourceType resource = 7;
  // Cleared Flag
  bool cleared = 8;
  // TTL in seconds for this Alert
  uint64 ttl = 9;
  // UniqueTag helps identify a unique alert for a given resouce
  string unique_tag = 10;
}

// Alerts is an array of Alert objects
// swagger:model
message Alerts {
  repeated Alert alert = 1;
}

// ObjectstoreInfo is a structure that has current objectstore info
// swagger:model
message ObjectstoreInfo {
    // UUID of objectstore
    string uuid = 1;
    // VolumeID of volume used by object store
    string volume_id = 2;
    // Enable/Disable created objectstore
    bool enabled = 3;
    // Status of objectstore running/failed
    string status = 4;
    // Action being taken on this objectstore
    int64 action = 5;
    // AccessKey for login into objectstore
    string access_key = 6;
    // SecretKey for login into objectstore
    string secret_key = 7;
    // Endpoints for accessing objectstore
    repeated string endpoints = 8;
    // CurrentEndpoint on which objectstore server is accessible
    string current_endpoint = 9;
    // AccessPort is objectstore server port
    int64 access_port = 10;
    // Region for this objectstore
    string region = 11;
}

// VolumeCreateRequest is a structure that has the locator, source and spec
// to create a volume
// swagger:model
message VolumeCreateRequest {
  // User specified volume name and labels
  VolumeLocator locator = 1;
  // Source to create volume
  Source source = 2;
  // The storage spec for the volume
  VolumeSpec spec = 3;
}

// VolumeResponse is a structure that wraps an error.
// swagger:response volumeResponse
message VolumeResponse {
  // Error message
  //
  // in: body
  // Required: true
  string error = 1;
}

// VolumeCreateResponse
// swagger:response volumeCreateResponse
message VolumeCreateResponse {
  // ID of the newly created volume
  //
  // in: body
  // Required: true
  string id = 1;
  // Volume Response
  //
  // in: body
  // Required: true
  VolumeResponse volume_response = 2;
}

// VolumeStateAction specifies desired actions.
// swagger:model
message VolumeStateAction {
  // Attach or Detach volume
  VolumeActionParam attach = 1;
  // Mount or unmount volume
  VolumeActionParam mount = 2;
  // MountPath Path where the device is mounted
  string mount_path = 3;
  // DevicePath Path returned in attach
  string device_path = 4;
}

// VolumeSet specifies a request to update a volume.
// swagger:model
message VolumeSetRequest {
  // User specified volume name and labels
  VolumeLocator locator = 1;
  // The storage spec for the volume
  VolumeSpec spec = 2;
  // State modification on this volume.
  VolumeStateAction action = 3;
  // additional options
  // required for the Set operation.
  map<string, string> options = 4;
}

// VolumeSetResponse
// swagger:response volumeSetResponse
message VolumeSetResponse {
  // Volume
  //
  // in: body
  // Required: true
  Volume volume = 1;
  //VolumeResponse
  //
  // in: body
  // Required: true
  VolumeResponse volume_response = 2;
}

// SnapCreateRequest specifies a request to create a snapshot of given volume.
// swagger:parameters snapVolume
message SnapCreateRequest {
  // volume id
  string id = 1;
  VolumeLocator locator = 2;
  bool readonly = 3;
}

// SnapCreateRequest specifies a response that get's returned when creating a snapshot.
// swagger:response snapCreateResponse
message SnapCreateResponse {
  // VolumeCreateResponse
  //
  // in: body
  // Required: true
  VolumeCreateResponse volume_create_response = 1;
}

// VolumeInfo
// swagger:model
message VolumeInfo {
  string volume_id = 1;
  string path = 2;
  VolumeSpec storage = 3;
}

// VolumeConsumer identifies a consumer for a Volume. An example of a VolumeConsumer
// would be a Pod in Kubernetes who has mounted the PersistentVolumeClaim for the
// Volume
// swagger: model
message VolumeConsumer {
  // Name is the name of the volume consumer
  string name = 1;
  // Namespace is the namespace of the volume consumer
  string namespace = 2;
  // Type is the type of the consumer. E.g a Kubernetes pod
  string type = 3;
  // NodeID is the identifier of the node on which the consumer is running. This
  // identifier would be from the perspective of the container runtime or
  // orchestrator under which the volume consumer resides. For example, NodeID
  //  can be name of a minion in Kubernetes.
  string node_id = 4;
  // OwnerName is the name of the entity who owns this volume consumer
  string owner_name = 5;
  // OwnerType is the type of the entity who owns this volume consumer. The type would
  // be from the perspective of the container runtime or the orchestrator under which
  // the volume consumer resides. For e.g OwnerType can be a Deployment in Kubernetes.
  string owner_type = 6;
}

// GraphDriverChanges represent a list of changes between the filesystem layers
// specified by the ID and Parent.  // Parent may be an empty string, in which
// case there is no parent.
// Where the Path is the filesystem path within the layered filesystem
// swagger:model
message GraphDriverChanges {
  string path = 1;
  GraphDriverChangeType kind = 2;
}

// ClusterResponse specifies a response that gets returned when requesting the cluster
// swagger:response clusterResponse
message ClusterResponse {
  // Error code
  //
  // in: body
  string error = 1;
}

// Active Request
// swagger:model
message ActiveRequest {
  map<int64, string> ReqestKV = 1;
}

// Active Requests
// swagger:model
message ActiveRequests {
  int64 RequestCount = 1;
  repeated ActiveRequest ActiveRequest = 2;
}

// GroupSnapCreateRequest specifies a request to create a snapshot of given group.
// swagger:model
message GroupSnapCreateRequest {
  string id = 1;
  map<string, string> Labels = 2;
}

// GroupSnapCreateRequest specifies a response that get's returned when creating a group snapshot.
// swagger:response groupSnapCreateResponse
message GroupSnapCreateResponse {
  // Created snapshots
  //
  // in: body
  // Required: true
  map<string, SnapCreateResponse> snapshots = 1;
  // Error message
  //
  // in: body
  // Required: true
  string error = 2;
}

// StorageNode describes the state of the node
message StorageNode {
  // Id of the node
  string id = 1;
  // Cpu usage of the node
  double cpu = 2;
  // Total memory of the node
  uint64 mem_total = 3;
  // Used memory of the node
  uint64 mem_used = 4;
  // Free memory of the node
  uint64 mem_free = 5;
  // Average load (percentage)
  int64 avg_load = 6;
  // Node status
  Status status = 7;
  // List of disks on the node
  map<string, StorageResource> disks = 9;
  // List of storage pools this node supports
  repeated StoragePool pools = 10;
  // Management IP
  string mgmt_ip = 11;
  // Data IP
  string data_ip = 12;
  // Hostname of the node
  string hostname = 15;
  // User defined labels for the node
  map<string, string> node_labels = 16;
}

// StorageCluster represents the state of the cluster
message StorageCluster {
  // Status of the cluster
  Status status = 1;
  // Id of the cluster
  string id = 2;
  // NodeId is the id of the node servicing these requests
  string node_id = 3;
  // Nodes are a list of all the nodes on the cluster
  repeated string node_ids = 4;
}

service OpenStorageCluster {
  // Enumerate lists all the nodes in the cluster.
  rpc Enumerate(SdkClusterEnumerateRequest)
    returns (SdkClusterEnumerateResponse) {
      option(google.api.http) = {
        get: "/v1/cluster"
      };
    }

  // Inspect the node given a UUID.
  rpc Inspect(SdkClusterInspectRequest)
    returns (SdkClusterInspectResponse) {
      option(google.api.http) = {
        get: "/v1/cluster/{node_id}"
      };
    }

  // Get a list of alerts from the storage cluster
  rpc AlertEnumerate(SdkClusterAlertEnumerateRequest)
    returns (SdkClusterAlertEnumerateResponse) {
      option(google.api.http) = {
        post: "/v1/cluster/alert/enumerate"
        body: "*"
      };
    }

  // Clear the alert for a given resource
  rpc AlertClear(SdkClusterAlertClearRequest)
    returns (SdkClusterAlertClearResponse) {
      option(google.api.http) = {
        post: "/v1/cluster/alert/clear"
        body: "*"
      };
    }

  // Erases an alert for a given resource
  rpc AlertDelete(SdkClusterAlertDeleteRequest)
    returns (SdkClusterAlertDeleteResponse) {
      option(google.api.http) = {
        delete: "/v1/cluster/alert/{alert_id}"
      };
    }
}

service OpenStorageVolume {
  // Creates a new volume
  rpc Create(SdkVolumeCreateRequest)
    returns (SdkVolumeCreateResponse) {
      option(google.api.http) = {
        post: "/v1/volume"
        body: "*"
      };
    }

  // Clone creates a new volume cloned from an existing volume
  rpc Clone(SdkVolumeCloneRequest)
    returns (SdkVolumeCloneResponse) {
      option(google.api.http) = {
        post: "/v1/volume/clone"
        body: "*"
      };
    }

  // Delete a volume
  rpc Delete(SdkVolumeDeleteRequest)
    returns (SdkVolumeDeleteResponse) {
      option(google.api.http) = {
        delete: "/v1/volume/{volume_id}"
      };
    }

  // Get information on a volume
  rpc Inspect(SdkVolumeInspectRequest)
    returns (SdkVolumeInspectResponse) {
      option(google.api.http) = {
        get: "/v1/volume/{volume_id}"
      };
    }

  // Get a list of volumes
  rpc Enumerate(SdkVolumeEnumerateRequest)
    returns (SdkVolumeEnumerateResponse) {
      option(google.api.http) = {
        post: "/v1/volume/enumerate"
        body: "*"
      };
    }

  // Create a snapshot of a volume. This creates an immutable (read-only),
  // point-in-time snapshot of a volume.
  rpc SnapshotCreate(SdkVolumeSnapshotCreateRequest)
    returns (SdkVolumeSnapshotCreateResponse) {
      option(google.api.http) = {
        post: "/v1/volume/snapshot"
        body: "*"
      };
    }

  // Restores a volume to a specified snapshot
  rpc SnapshotRestore(SdkVolumeSnapshotRestoreRequest)
    returns (SdkVolumeSnapshotRestoreResponse) {
      option(google.api.http) = {
        post: "/v1/volume/snapshot/restore"
        body: "*"
      };
    }

  // List the number of snapshots for a specific volume
  rpc SnapshotEnumerate(SdkVolumeSnapshotEnumerateRequest)
    returns (SdkVolumeSnapshotEnumerateResponse) {
      option(google.api.http) = {
        post: "/v1/volume/snapshot/enumerate"
        body: "*"
      };
    }

  // Attach device to host
  rpc Attach(SdkVolumeAttachRequest)
    returns (SdkVolumeAttachResponse) {
      option(google.api.http) = {
        post: "/v1/volume/attach"
        body: "*"
      };
    }

  // Detaches the volume from the node.
  rpc Detach(SdkVolumeDetachRequest)
    returns (SdkVolumeDetachResponse) {
      option(google.api.http) = {
        post: "/v1/volume/detach"
        body: "*"
      };
    }

  // Attaches the volume to a node.
  rpc Mount(SdkVolumeMountRequest)
    returns(SdkVolumeMountResponse) {
      option(google.api.http) = {
        post: "/v1/volume/mount"
        body: "*"
      };
    }

  // Unmount volume at specified path
  rpc Unmount(SdkVolumeUnmountRequest)
      returns(SdkVolumeUnmountResponse) {
      option(google.api.http) = {
        post: "/v1/volume/unmount"
        body: "*"
      };
    }
}

service OpenStorageObjectstore {
  // Inspect returns current status of objectstore
  rpc Inspect(SdkObjectstoreInspectRequest)
    returns(SdkObjectstoreInspectResponse){
      option(google.api.http) = {
        get: "/v1/objectstore/{objectstore_id}"
      };
    }

  // Creates objectstore on specified volume
  rpc Create(SdkObjectstoreCreateRequest)
    returns(SdkObjectstoreCreateResponse){
      option(google.api.http) = {
        post: "/v1/objectstore"
        body: "*"
      };
    }

  // Deletes objectstore by id
  rpc Delete(SdkObjectstoreDeleteRequest)
    returns(SdkObjectstoreDeleteResponse){
      option(google.api.http) = {
        delete: "/v1/objectstore/{objectstore_id}"
      };
    }

  // Updates provided objectstore status
  rpc Update(SdkObjectstoreUpdateRequest)
    returns(SdkObjectstoreUpdateResponse){
      option(google.api.http) ={
        post: "/v1/objectstore/update"
        body: "*"
      };
  }
}

service OpenStorageCredentials {

  // Provide credentials to OpenStorage and if valid,
  // it will return an identifier to the credentials

  // Create cloud credentials
  rpc Create(SdkCredentialCreateRequest)
    returns (SdkCredentialCreateResponse) {
      option(google.api.http) = {
        post: "/v1/credentials"
        body: "*"
      };
    }

  // Enumerate returns a list of credential ids
  rpc Enumerate(SdkCredentialEnumerateRequest)
    returns (SdkCredentialEnumerateResponse) {
      option(google.api.http) = {
        get: "/v1/credentials"
      };
    }

  // Inspect returns the information about a credential
  rpc Inspect(SdkCredentialInspectRequest)
    returns (SdkCredentialInspectResponse) {
      option(google.api.http) = {
        get: "/v1/credentials/{credential_id}"
      };
    }

  // Delete a specified credential
  rpc Delete(SdkCredentialDeleteRequest)
    returns (SdkCredentialDeleteResponse){
      option(google.api.http) = {
        delete: "/v1/credentials/{credential_id}"
      };
    }

  // Validate a specified credential
  rpc Validate(SdkCredentialValidateRequest)
    returns (SdkCredentialValidateResponse) {
      option(google.api.http) = {
        get: "/v1/credentials/validate/{credential_id}"
      };
    }
}

service OpenStorageSchedulePolicy {

  // Create Schedule Policy for snapshots
  rpc Create(SdkSchedulePolicyCreateRequest)
    returns (SdkSchedulePolicyCreateResponse) {
      option(google.api.http) = {
        post: "/v1/schedulepolicy"
        body: "*"
      };
    }

  // Update Schedule Policy
  rpc Update(SdkSchedulePolicyUpdateRequest)
    returns (SdkSchedulePolicyUpdateResponse) {
      option(google.api.http) = {
        post: "/v1/schedulepolicy/update"
        body: "*"
      };
    }

  rpc Enumerate(SdkSchedulePolicyEnumerateRequest)
    returns (SdkSchedulePolicyEnumerateResponse) {
      option(google.api.http) = {
        get: "/v1/schedulepolicy"
      };
    }

  // Inspect Schedule Policy
  rpc Inspect(SdkSchedulePolicyInspectRequest)
  returns (SdkSchedulePolicyInspectResponse) {
    option(google.api.http) = {
      get: "/v1/schedulepolicy/{name}"
    };
  }

  // Delete Schedule Policy
  rpc Delete(SdkSchedulePolicyDeleteRequest)
    returns (SdkSchedulePolicyDeleteResponse) {
      option(google.api.http) = {
        delete: "/v1/schedulepolicy/{name}"
      };
    }
}

service OpenStorageCloudBackup {

  // Create
  rpc Create(SdkCloudBackupCreateRequest)
    returns (SdkCloudBackupCreateResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackup"
        body: "*"
      };
    }

  // Restore
  rpc Restore(SdkCloudBackupRestoreRequest)
    returns (SdkCloudBackupRestoreResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackup/restore"
        body: "*"
      };
    }

  // Delete
  rpc Delete(SdkCloudBackupDeleteRequest)
    returns (SdkCloudBackupDeleteResponse) {
      option(google.api.http) = {
        delete: "/v1/cloudbackup/{backup_id}"
      };
    }

  // DeleteAll
  rpc DeleteAll(SdkCloudBackupDeleteAllRequest)
    returns (SdkCloudBackupDeleteAllResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackup/deleteall"
        body: "*"
      };
    }

  // Enumerate
  rpc Enumerate(SdkCloudBackupEnumerateRequest)
    returns (SdkCloudBackupEnumerateResponse) {
      option(google.api.http) = {
        get: "/v1/cloudbackup"
      };
    }

  // Status
  rpc Status(SdkCloudBackupStatusRequest)
    returns (SdkCloudBackupStatusResponse) {
      option(google.api.http) = {
        get: "/v1/cloudbackup/status/{src_volume_id}"
      };
    }

  // Catalog
  rpc Catalog(SdkCloudBackupCatalogRequest)
    returns (SdkCloudBackupCatalogResponse) {
      option(google.api.http) = {
        get: "/v1/cloudbackup/catalog/{backup_id}"
      };
    }

  // History
  rpc History(SdkCloudBackupHistoryRequest)
    returns (SdkCloudBackupHistoryResponse) {
      option(google.api.http) = {
        get: "/v1/cloudbackup/history/{src_volume_id}"
      };
    }

  // StateChange
  rpc StateChange(SdkCloudBackupStateChangeRequest)
    returns (SdkCloudBackupStateChangeResponse) {
      option(google.api.http) = {
        post: "/v1/cloudbackup/statechange"
        body: "*"
      };
    }
}

message SdkSchedulePolicyCreateRequest {
  // Schedule Policy
  SdkSchedulePolicy SchedulePolicy = 1;
}

message SdkSchedulePolicyCreateResponse {
}

message SdkSchedulePolicyUpdateRequest {
  // Schedule Policy
  SdkSchedulePolicy SchedulePolicy = 1;
}

message SdkSchedulePolicyUpdateResponse {
}

message SdkSchedulePolicyEnumerateRequest {
}

message SdkSchedulePolicyEnumerateResponse {
  // List of Schedule Policy
  repeated SdkSchedulePolicy policies = 1;
}

message SdkSchedulePolicyInspectRequest {
  // Name of the schedule Policy
  string name = 1;
}

message SdkSchedulePolicyInspectResponse {
  // List of Schedule Policy
  SdkSchedulePolicy policy = 1;
}

message SdkSchedulePolicyDeleteRequest {
  // Name of the schedule policy
  string name = 1;
}

message SdkSchedulePolicyDeleteResponse {
}

enum SdkTimeWeekday {
  SdkTimeWeekdaySunday = 0;
  SdkTimeWeekdayMonday = 1;
  SdkTimeWeekdayTuesday = 2;
  SdkTimeWeekdayWednesday = 3;
  SdkTimeWeekdayThursday = 4;
  SdkTimeWeekdayFriday = 5;
  SdkTimeWeekdaySaturday = 6;
}

message SdkSchedulePolicyIntervalDaily {
  // Range: 0-23
  int32 hour = 1;
  // Range: 0-59
  int32 minute = 2;
}

message SdkSchedulePolicyIntervalWeekly{
  SdkTimeWeekday day = 1;
  // Range: 0-23
  int32 hour = 2;
  // Range: 0-59
  int32 minute = 3;
}

message SdkSchedulePolicyIntervalMonthly{
  // Range: 1-28
  int32 day = 1;
  // Range: 0-59
  int32 hour = 2;
  // Range: 0-59
  int32 minute = 3;
}

message SdkSchedulePolicyInterval {
  // Number of instances to retain
  int64 retain = 1;

  oneof period_type {
    // Daily policy
    SdkSchedulePolicyIntervalDaily daily = 2;
    // Weekly policy
    SdkSchedulePolicyIntervalWeekly weekly = 3;
    // Monthly policy
    SdkSchedulePolicyIntervalMonthly monthly = 4;
  }
}

message SdkSchedulePolicy {
  // Name of the schedule policy
  string name = 1;
  // Schedule policy
  SdkSchedulePolicyInterval schedule = 2;
}

message SdkCredentialCreateRequest {
  oneof credential_type {
    SdkAwsCredentialRequest aws_credential = 1;
    SdkAzureCredentialRequest azure_credential = 2;
    SdkGoogleCredentialRequest google_credential = 3;
  }
}

message SdkCredentialCreateResponse {
  // Id of the credentials
  string credential_id = 1;
}

message SdkAwsCredentialRequest {
  // Access key
  string access_key = 1;
  // Secret key
  string secret_key = 2;
  // Endpoint
  string endpoint = 3;
  // Region
  string region = 4;
}

message SdkAzureCredentialRequest {
  // Account name
  string account_name = 1;
  // Account key
  string account_key = 2;
}

message SdkGoogleCredentialRequest {
  // Project ID
  string project_id = 1;
  // JSON Key
  string json_key = 2;
}

message SdkAwsCredentialResponse {
  // Credential Id
  string credential_id = 1;
  // Access key
  string access_key = 2;
  // Endpoint
  string endpoint = 3;
  // Region
  string region = 4;
}

message SdkAzureCredentialResponse {
  // Credential Id
  string credential_id = 1;
  // Account name
  string account_name = 2;
}

message SdkGoogleCredentialResponse {
  // Credential Id
  string credential_id = 1;
  // Project ID
  string project_id = 2;
}

message SdkCredentialEnumerateRequest {
}

message SdkCredentialEnumerateResponse {
  repeated string credential_ids = 1;
}

message SdkCredentialInspectRequest {
  string credential_id = 1;
}

// This response uses OneOf proto style. Depending on your programming language
// you will need to check if the value of credential_type is one of the ones below.
message SdkCredentialInspectResponse {
  oneof credential_type {
    SdkAwsCredentialResponse aws_credential = 1;
    SdkAzureCredentialResponse azure_credential = 2;
    SdkGoogleCredentialResponse google_credential = 3;
  }
}

message SdkCredentialDeleteRequest {
  // ID for credentials
  string credential_id = 1;
}

message SdkCredentialDeleteResponse {
}

message SdkCredentialValidateRequest {
  // Id of the credentials
  string credential_id = 1;
}

message SdkCredentialValidateResponse {
}

message SdkVolumeMountRequest {
  // Id of the volume
  string volume_id = 1;
  // Mount path for mounting the volume.
  string mount_path = 2;
  // Additional options
  map<string, string> options = 3;
}

message SdkVolumeMountResponse {
}

message SdkVolumeUnmountRequest {
  // Id of volume
  string volume_id = 1;
  // MountPath for device
  string mount_path = 2;
  // Options to unmount device
  map<string, string> options = 3;
}

message SdkVolumeUnmountResponse {
}

message SdkVolumeAttachRequest {
  // Id of volume
  string volume_id = 1;
  // Options for attaching volume, right now only passphrase options is supported
  map<string, string>  options = 2;
}

message SdkVolumeAttachResponse {
  // Device path where device is exported
  string device_path = 1;
}

message SdkVolumeDetachRequest {
  // Id of the volume
  string volume_id = 1;
}

message SdkVolumeDetachResponse {
}

message SdkVolumeCreateRequest {
  // Unique name of the volume. This will be used for idempotency.
  string name = 1;
  // Volume specification
  VolumeSpec spec = 2;
}

message SdkVolumeCreateResponse {
  // Id of new volume
  string volume_id = 1;
}

message SdkVolumeCloneRequest {
  // Unique name of the volume. This will be used for idempotency.
  string name = 1;
  // Parent volume id, if specified will create a new volume as a clone of the parent.
  string parent_id = 2;
  // Volume specification
  VolumeSpec spec = 3;
}

message SdkVolumeCloneResponse {
  // Id of new volume
  string volume_id = 1;
}

message SdkVolumeDeleteRequest {
  // Id of volume to delete
  string volume_id = 1;
}

message SdkVolumeDeleteResponse {
}

message SdkVolumeInspectRequest {
  // Id of volume to inspect
  string volume_id = 1;
}

message SdkVolumeInspectResponse {
  // Information about the volume
  Volume volume = 1;
}

message SdkVolumeEnumerateRequest {
  // Volumes to match to this locator.
  // If not provided, all volumes will be returned.
  VolumeLocator locator = 1;
}

message SdkVolumeEnumerateResponse {
  // List of volumes matching label
  repeated string volume_ids = 1;
}

message SdkVolumeSnapshotCreateRequest{
  // Id of volume to take the snapshot from
  string volume_id = 1;
  // Labels to apply to snapshot
  map<string, string> labels = 2;
}

message SdkVolumeSnapshotCreateResponse {
  // Id of immutable snapshot
  string snapshot_id = 1;
}

message SdkVolumeSnapshotRestoreRequest {
  // Id of volume
  string volume_id = 1;
  // Snapshot id to apply to `volume_id`
  string snapshot_id = 2;
}

message SdkVolumeSnapshotRestoreResponse {
}

message SdkVolumeSnapshotEnumerateRequest {
  // Id of volume
  string volume_id = 1;
  // Labels from snapshot
  map<string, string> labels = 2;
}

message SdkVolumeSnapshotEnumerateResponse {
  // List of immutable snapshots
  repeated string volume_snapshot_ids = 1;
}

message SdkClusterEnumerateRequest {
}

message SdkClusterEnumerateResponse {
  // Cluster information
  StorageCluster cluster = 1;
}

message SdkClusterInspectRequest {
  // Id of node to inspect (required)
  string node_id = 1;
}

message SdkClusterInspectResponse {
  // Node information
  StorageNode node = 1;
}

message SdkClusterAlertEnumerateRequest {
  // Start time of alerts (required)
  google.protobuf.Timestamp time_start = 1;
  // End time of alerts (required)
  google.protobuf.Timestamp time_end = 2;
  // Type of resource (required)
  ResourceType resource = 3;
}

message SdkClusterAlertEnumerateResponse {
  // Information on the alerts requested
  repeated Alert alerts = 1;
}

message SdkClusterAlertClearRequest {
  // Type of resource (required)
  ResourceType resource = 1;
  // Id of alert as returned by ClusterEnumerateAlertResponse (required)
  int64 alert_id = 2;
}

message SdkClusterAlertClearResponse {
}

message SdkClusterAlertDeleteRequest {
  // Type of resource (required)
  ResourceType resource = 1;
  // Id of alert as returned by ClusterEnumerateAlertResponse (required)
  int64 alert_id = 2;
}

message SdkClusterAlertDeleteResponse {
}

message SdkObjectstoreInspectRequest {
  //ObjecstoreID to query objestore status
  string objectstore_id = 1;
}

message SdkObjectstoreInspectResponse {
  // Objectstore status
  ObjectstoreInfo objectstore_status = 1;
}

message SdkObjectstoreCreateRequest {
  // Volume on which objectstore will be running
  string volume_id= 1;
}

message SdkObjectstoreCreateResponse {
  // Created objecstore status
  ObjectstoreInfo objectstore_status = 1;
}

message SdkObjectstoreDeleteRequest {
  // Objectstore ID to delete
  string objectstore_id = 1;
}

message SdkObjectstoreDeleteResponse {
}

message SdkObjectstoreUpdateRequest {
  // Objectstore Id to update
  string objectstore_id = 1;
  // enable/disable objectstore
  bool enable = 2;
}

message SdkObjectstoreUpdateResponse {
}

message SdkCloudBackupCreateRequest {
  // VolumeID of the volume for which cloudbackup is requested
  string volume_id = 1;
  // CredentialUUID is cloud credential to be used for backup
  string credential_uuid = 2;
  // Full indicates if full backup is desired even though incremental is possible
  bool full = 3;
}

message SdkCloudBackupCreateResponse {
  // Id of the backup created
  string backup_id = 1;
}

message SdkCloudBackupRestoreRequest {
  // Backup ID being restored
  string backup_id = 1;
  // Optional volume Name of the new volume to be created
  // in the cluster for restoring the cloudbackup
  string restore_volume_name = 2;
  // The credential to be used for restore operation
  string credential_uuid = 3;
  // Optional for provisioning restore
  // volume (ResoreVolumeName should not be specified)
  string node_id = 4;
}

message SdkCloudBackupRestoreResponse {
  // VolumeID to which the backup is being restored
  string restore_volume_id = 1;
}

message SdkCloudBackupDeleteRequest {
  // ID is the ID of the cloud backup
  string backup_id = 1;
  // CredentialUUID is the credential for cloud to be used for the request
  string credential_uuid = 2;
  // Force Delete cloudbackup even if there are dependencies
  bool force = 3;
}

message SdkCloudBackupDeleteResponse {
}

message SdkCloudBackupDeleteAllRequest {
  // id of the volume for the request
  string src_volume_id = 1;
  // CredentialUUID is the credential for cloud to be used for the request
  string credential_uuid = 2;
}

message SdkCloudBackupDeleteAllResponse {
}

message SdkCloudBackupEnumerateRequest {
  // Optional source id of the volume for the request
  string src_volume_id = 1;
  // ClusterID is the optional clusterID for the request
  string cluster_id = 2;
  // CredentialUUID is the credential for cloud to be used for the request
  string credential_uuid = 3;
  // All if set to true, backups for all clusters in the cloud are processed
  bool all = 4;
}

message SdkCloudBackupInfo {
  // ID is the ID of the cloud backup
  string id = 1;
  // Source volumeID of the backup
  string src_volume_id = 2;
  // Name of the sourceVolume of the backup
  string src_volume_name = 3;
  // Timestamp is the timestamp at which the source volume
  // was backed up to cloud
  google.protobuf.Timestamp timestamp = 4;
  // Metadata associated with the backup
  map<string, string> metadata = 5;
  // Status indicates the status of the backup
  SdkCloudBackupStatusType status = 6;
}

message SdkCloudBackupEnumerateResponse {
  repeated string backup_ids = 1;
}

enum SdkCloudBackupOpType {
  SdkCloudBackupOpTypeUnknown = 0;
  SdkCloudBackupOpTypeBackupOp = 1;
  SdkCloudBackupOpTypeRestoreOp = 2;
}

enum SdkCloudBackupStatusType {
  SdkCloudBackupStatusTypeUnknown = 0;
  SdkCloudBackupStatusTypeNotStarted = 1;
  SdkCloudBackupStatusTypeDone = 2;
  SdkCloudBackupStatusTypeAborted = 3;
  SdkCloudBackupStatusTypePaused = 4;
  SdkCloudBackupStatusTypeStopped = 5;
  SdkCloudBackupStatusTypeActive = 6;
  SdkCloudBackupStatusTypeFailed = 7;
}

message SdkCloudBackupStatus {
  // ID is the ID for the operation
  string backup_id = 1;
  // OpType indicates if this is a backup or restore
  SdkCloudBackupOpType optype = 2;
  // State indicates if the op is currently active/done/failed
  SdkCloudBackupStatusType status = 3;
  // BytesDone indicates total Bytes uploaded/downloaded
  uint64 bytes_done = 4;
  // StartTime indicates Op's start time
  google.protobuf.Timestamp start_time = 5;
  // CompletedTime indicates Op's completed time
  google.protobuf.Timestamp completed_time = 6;
  // NodeID is the ID of the node where this Op is active
  string node_id = 7;
}

message SdkCloudBackupStatusRequest {
  // SrcVolumeID optional volumeID to list status of backup/restore
  string src_volume_id = 1;
  // Local indicates if only those backups/restores that are
  // active on current node must be returned
  bool local = 2;
}

message SdkCloudBackupStatusResponse {
  // statuses is list of currently active/failed/done backup/restores
  map<string, SdkCloudBackupStatus> statuses = 1;
}

message SdkCloudBackupCatalogRequest {
  // Id of the backup
  string backup_id = 1;
  // is the credential for cloud
  string credential_uuid = 2;
}

message SdkCloudBackupCatalogResponse {
  // Contents is listing of backup contents
  repeated string contents = 1;
}

message SdkCloudBackupHistoryItem {
  // SrcVolumeID is volume ID which was backedup
  string src_volume_id = 1;
  // TimeStamp is the time at which either backup completed/failed
  google.protobuf.Timestamp timestamp = 2;
  // Status indicates whether backup was completed/failed
  SdkCloudBackupStatusType status = 3;
}

message SdkCloudBackupHistoryRequest {
  // volumeID for which history of backup/restore is being requested
  // (optional) If not provided, it will return the history for all volumes.
  string src_volume_id = 1;
}

message SdkCloudBackupHistoryResponse {
  // HistoryList is list of past backup/restores in the cluster
  repeated SdkCloudBackupHistoryItem history_list = 1;
}

enum SdkCloudBackupRequestedState {
  SdkCloudBackupRequestedStateUnknown = 0;
  SdkCloudBackupRequestedStatePause = 1;
  SdkCloudBackupRequestedStateResume = 2;
  SdkCloudBackupRequestedStateStop = 3;
}

message SdkCloudBackupStateChangeRequest {
  // SrcVolumeID is volume ID on which backup/restore
  // state change is being requested
  string src_volume_id = 1;
  // RequestedState is desired state of the op
  // can be pause/resume/stop
  SdkCloudBackupRequestedState requested_state = 2;
}

message SdkCloudBackupStateChangeResponse {
}
